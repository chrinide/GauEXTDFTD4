# include <stdio.h>
# include <string.h>

/*  This program read output files from External steps.  */

/*  these functions are implied in fortran programs.  */
/*  only declarations are made here.  */
void read_three_double_(char const *readstr, double *valuep1, double *valuep2, double *valuep3);
void read_one_double_(char const *readstr, double *valuep);
void write_four_double_(char *writestr, double const *valuep1, double const *valuep2, \
                                        double const *valuep3, double const *valuep4);
void write_three_double_(char *writestr, double const *valuep1, \
                         double const *valuep2, double const *valuep3);

double readHessianNext(FILE *hessfp, unsigned int maxIndex);


int main(int argc, const char *const argv[])
{
  char line[BUFSIZ + 1] = "";
  FILE *iflp0 = NULL;  /*  input file generated by Gaussian External  */
  FILE *iflp1 = NULL;  /*  Gaussian temporary output file  */
  FILE *iflp2 = NULL;  /*  DFT-D4 output file  */
  FILE *iflp3 = NULL;  /*  DFT-D4 gradient  */
  FILE *oflp0 = NULL;  /*  Gaussian external output file  */
  unsigned int natoms = 0;
  unsigned int ngrad = 0;
  double energy_gau = 0., energy_dftd4 = 0., energy = 0.;
  double xGrad_gau = 0., yGrad_gau = 0., zGrad_gau = 0.;
  double xGrad_dftd4 = 0., yGrad_dftd4 = 0., zGrad_dftd4 = 0.;
  double xGrad = 0., yGrad = 0., zGrad = 0.;
  double xDipo = 0., yDipo = 0., zDipo = 0.;
  double HessEle[3] = {0.0, 0.0, 0.0};
  unsigned int i = 0;
  double const uselessZero = 0.0;
  char outputLineForThree[20 * 3 + 1] = "";
  char outputLineForFour[20 * 4 + 1] = "";
  unsigned int sizeHessian = 0;


  /*  set end of strings  */
  outputLineForThree[20 * 3] = '\0';
  outputLineForFour[20 * 4] = '\0';

  /*  open output file for Gaussian external  */
  oflp0 = fopen(argv[2], "wt");

  /*  acquire number of atoms and gradients  */
  iflp0 = fopen(argv[1], "rt");
  fgets(line, BUFSIZ, iflp0);
  sscanf(line, "%u %u", & natoms, & ngrad);
  sizeHessian = 3 * natoms;
  fclose(iflp0);
  iflp0 = NULL;

  /*  acquire Gaussian energy  */
  iflp1 = fopen("useExtGau.out", "rt");
  while (! feof(iflp1))
  {
    fgets(line, BUFSIZ, iflp1);
    if (strstr(line, "SCF Done"))
    {
      sscanf(strchr(line, '=') + strlen("="), "%lf", & energy_gau);
      break;
    }
  }
  fseek(iflp1, 0, SEEK_SET);

  /*  acquire DFT-D4 energy */
  iflp2 = fopen("useExtDFTD4.out", "rt");
  while (! feof(iflp2))
  {
    fgets(line, BUFSIZ, iflp2);
    if (ngrad)
    {
      if (strstr(line, "E(opt) /kcal,au:"))
      {
        sscanf(strstr(line, "E(opt) /kcal,au:") + strlen("E(opt) /kcal,au:"), "%*lf %lf", & energy_dftd4);
        break;
      }
    }
    else
    {
      if (strstr(line, "Edisp  /kcal,au:"))
      {
        sscanf(strstr(line, "Edisp  /kcal,au:") + strlen("Edisp  /kcal,au:"), "%*lf %lf", & energy_dftd4);
        break;
      }
    }
  }
  fseek(iflp2, 0, SEEK_SET);

  /*  total energy  */
  energy = energy_gau + energy_dftd4;

  /*  dipole-moment, without DFT-D4  */
  while (! feof(iflp1))
  {
    fgets(line, BUFSIZ, iflp1);
    if (strstr(line, "Dipole moment (field-independent basis, Debye)"))
    {
      fgets(line, BUFSIZ, iflp1);
      sscanf(strchr(line, 'X'), "X= %lf Y= %lf Z= %lf", & xDipo, & yDipo, & zDipo);
      break;
    }
  }
  fseek(iflp1, 0, SEEK_SET);
  write_four_double_(outputLineForFour, & energy, & xDipo, & yDipo, & zDipo);
  fprintf(oflp0, "%s\n", outputLineForFour);

  /*  if 1st derivatives are needed  */
  if (ngrad >= 1)
  {
    iflp3 = fopen("gradient", "rt");
    while (! feof(iflp1))
    {
      fgets(line, BUFSIZ, iflp1);
      if (strstr(line, "***** Axes restored to original set *****"))
        break;
      /*  that guaranteed that only the force of input orientation,  */
      /*  instead of the standard orientation is read.  */
    }
    while (! feof(iflp1))
    {
      fgets(line, BUFSIZ, iflp1);
      if (strstr(line, "Forces (Hartrees/Bohr)"))
        break;
    }
    /*  these lines are useless  */
    fgets(line, BUFSIZ, iflp1);
    fgets(line, BUFSIZ, iflp1);
    fgets(line, BUFSIZ, iflp3);
    fgets(line, BUFSIZ, iflp3);
    for (i = 1; i <= natoms; ++ i)
      fgets(line, BUFSIZ, iflp3);
    for (i = 1; i <= natoms; ++ i)
    {
      fgets(line, BUFSIZ, iflp1);
      /*  the next line actually reads force, which is the opposite number of gradient.  */
      sscanf(line, "%*d %*d %lf %lf %lf", & xGrad_gau, & yGrad_gau, & zGrad_gau);
      xGrad_gau = - xGrad_gau;
      yGrad_gau = - yGrad_gau;
      zGrad_gau = - zGrad_gau;
      fgets(line, BUFSIZ, iflp3);
      read_three_double_(line, & xGrad_dftd4, & yGrad_dftd4, & zGrad_dftd4);
      xGrad = xGrad_gau + xGrad_dftd4;
      yGrad = yGrad_gau + yGrad_dftd4;
      zGrad = zGrad_gau + zGrad_dftd4;
      write_three_double_(outputLineForThree, & xGrad, & yGrad, & zGrad);
      fprintf(oflp0, "%s\n", outputLineForThree);
    }
    fseek(iflp3, 0, SEEK_SET);
    fclose(iflp3);
    iflp3 = NULL;
    fseek(iflp1, 0, SEEK_SET);
  }

  /*  polarizability and dipole derivatives, not used in current version, just write 0  */
  /*  polarizability  */
  write_three_double_(outputLineForThree, & uselessZero, & uselessZero, & uselessZero);
  fprintf(oflp0, "%s\n", outputLineForThree);
  write_three_double_(outputLineForThree, & uselessZero, & uselessZero, & uselessZero);
  fprintf(oflp0, "%s\n", outputLineForThree);
  /*  dipole derivatives  */
  for (i = 1; i <= natoms; ++ i)
  {
    write_three_double_(outputLineForThree, & uselessZero, & uselessZero, & uselessZero);
    fprintf(oflp0, "%s\n", outputLineForThree);
    write_three_double_(outputLineForThree, & uselessZero, & uselessZero, & uselessZero);
    fprintf(oflp0, "%s\n", outputLineForThree);
    write_three_double_(outputLineForThree, & uselessZero, & uselessZero, & uselessZero);
    fprintf(oflp0, "%s\n", outputLineForThree);
  }

  /* if 2nd derivatives are needed, this function has not been completed yet.  */
  if (ngrad >= 2)
  {
    while (! feof(iflp2))
    {
      fgets(line, BUFSIZ, iflp2);
      if (strstr(line, "NOTE: Printing only the lower triangle"))
        break;
    }
    fgets(line, BUFSIZ, iflp2);
    while (! feof(iflp1))
    {
      fgets(line, BUFSIZ, iflp1);
      if (strstr(line, "Hessian after L703:"))
        break;
    }
    /*  this is a lower triangle matrix, in DFT-D4 it is row-priority  */
    for (i = natoms * (sizeHessian + 1) / 2; i > 0; -- i) /*  just for counting  */
    {
      fgets(line, BUFSIZ, iflp2);
      sscanf(line, "%lf %lf %lf", HessEle, HessEle + 1, HessEle + 2);
      HessEle[0] += readHessianNext(iflp1, sizeHessian);
      HessEle[1] += readHessianNext(iflp1, sizeHessian);
      HessEle[2] += readHessianNext(iflp1, sizeHessian);
      write_three_double_(outputLineForThree, HessEle, HessEle + 1, HessEle + 2);
      fprintf(oflp0, "%s\n", outputLineForThree);
    }
    fseek(iflp1, 0, SEEK_SET);
    fseek(iflp2, 0, SEEK_SET);
  }

  /*  file iflp1 and iflp2 have not been closed yet, close them.  */
  fclose(iflp1);
  iflp1 = NULL;
  fclose(iflp2);
  iflp2 = NULL;

  /*  file oflp0 has not been closed yet, close it.  */
  fclose(oflp0);
  oflp0 = NULL;

  return 0;
}


double readHessianNext(FILE *hessfp, unsigned int maxIndex)
{
  static char buf[BUFSIZ + 1] = "";
  static char *token = NULL;
  char const splitter[] = " \r\n";
  static unsigned int row = 1;
  static unsigned int col = 1;
  static long lastStartRowPos = 0;
  double value = 0.0;
  unsigned int jumpLine = 0;
  static unsigned int jumpLineToNextGroup = 0;
  unsigned const maxCol = 5;

  /*  this should never happen  */
  if (row > maxIndex)
    return 0.0;

  /*  start from the first group  */
  if (row == 1 && col == 1)
  {
    fgets(buf, BUFSIZ, hessfp);
    lastStartRowPos = ftell(hessfp);
  }

  if (col == 1)
  {
    jumpLineToNextGroup = maxIndex + 1 - maxCol;
    fseek(hessfp, lastStartRowPos, SEEK_SET);
    fgets(buf, BUFSIZ, hessfp);
    strtok(buf, splitter);
    lastStartRowPos = ftell(hessfp);
  }
  token = strtok(NULL, splitter);
  if (! token)
  {
    for (jumpLine = 0; jumpLine < jumpLineToNextGroup; ++ jumpLine)
      fgets(buf, BUFSIZ, hessfp);
    jumpLineToNextGroup -= maxCol;
    strtok(buf, splitter);
    token = strtok(NULL, splitter);
  }
  if (token[0] != '-')
  {
    -- token;
    token[0] = ' ';
  }
  read_one_double_(token, & value);

  ++ col;
  if (col > row)
  {
    ++ row;
    col = 1;
  }

  return value;

}

